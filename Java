/*
 * This program encrypts and decrypts messages by inputting a message
 * and stating the number of rows you'd like the encryption to contain.
 * Author: Paige Wiley
 * Date: 4-8-2022
 */
package com.example.cryptographyproject;

import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;

import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity implements View.OnClickListener{
boolean caesar = false;
boolean vigenere = false;
boolean scytale = false;
TextView shifts;
EditText encryptMsg;
EditText decryptMsg;
TextView output;
String encryptWord;
String decryptWord;
int key;
String strgkey;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);


        shifts = this.findViewById(R.id.inputShifts);
        encryptMsg = (EditText)this.findViewById(R.id.inputEncrypt);
        decryptMsg = (EditText)this.findViewById(R.id.inputDecrypt);



        output = this.findViewById(R.id.outputMes);

        Button encrypt = (Button)this.findViewById(R.id.encryptBtn);
        Button decrypt = (Button)this.findViewById(R.id.decryptBtn);




    }




    //When a radio button is clicked
    public void onRadioButtonClicked(View view){

        /*
         * I used code from the Android developers api
         * URL: https://developer.android.com/guide/topics/ui/controls/radiobutton
         * I used this code to check which radio button was clicked.
         */
        boolean checked = ((RadioButton) view).isChecked();

        switch(view.getId()){
            case R.id.cipherCaesar:
                if(checked)
                    caesar = true;
                break;
            case R.id.cipherScy:
                if(checked)
                    scytale = true;
                break;
            case R.id.cipherVig:
                if(checked)
                    vigenere = true;
                break;
        }
    }

    //When encrypt/decrypt buttons are pushed
    public void onClick(View view) {
       Button btn = (Button)view;

        //convert textview messages into strings
        encryptWord = encryptMsg.getText().toString();
        decryptWord = decryptMsg.getText().toString();

        /*
         *I used code from stackoverflow.com
         * URL: https://stackoverflow.com/questions/15037465/converting-edittext-to-int-android
         * I used this code to convert an edit text widget into an integer for the number of shifts in the ciphers.
         */
        strgkey = shifts.getText().toString();
        if(strgkey.charAt(0) >= 48 && strgkey.charAt(0) <= 57) { //if the key is a number shift
            key = Integer.parseInt(strgkey);
        }

        //encrypt the encrypt message
       if(btn.getText().equals("Encrypt")){
         if(caesar){ //if caesar is picked
            encryptCaesar();
         } else if (vigenere) { //if vigenere is picked
            encryptVigenere();
         }else if (scytale) { //if scytale is picked
             encryptScytale();
         }
           //decrypt the decrypt message
       }else if(btn.getText().equals("Decrypt")){
           if(caesar){ //if caesar is picked
                decryptCaesar();
           } else if (vigenere) { //if vigenere is picked
               decryptVigenere();
           }else if (scytale) { //if scytale is picked
               decryptScytale();
           }
       }
    }

    public void encryptCaesar(){
       System.out.println("Caesar encrypt");
       int[] caesarArray = new int[encryptWord.length()];
       for(int i = 0; i < encryptWord.length(); i++){
           if(encryptWord.charAt(i) + key > 122){
               caesarArray[i] = encryptWord.charAt(i) + key - 26; //returns back to a
           } else if(encryptWord.charAt(i) == 32){
               caesarArray[i] = 32;
           } else {
               caesarArray[i] = encryptWord.charAt(i) + key;
           }
       }

       String outputString = "";
       char[] caesarChars = new char[encryptWord.length()];
       for(int i = 0; i < encryptWord.length(); i++){
           caesarChars[i] = (char)(caesarArray[i]);
           outputString += caesarChars[i];
       }
        String upperOutput = outputString.toUpperCase();
       output.setText("Message: " + upperOutput);

    }

    public void decryptCaesar(){
        int[] caesarArray = new int[decryptWord.length()];
        for(int i = 0; i < decryptWord.length(); i++){
            if(decryptWord.charAt(i) - key < 97){
                caesarArray[i] = decryptWord.charAt(i) - key + 26; //returns back to a
            } else if(decryptWord.charAt(i) == 32){
                caesarArray[i] = 32;
            } else {
                caesarArray[i] = decryptWord.charAt(i) - key;
            }
        }
        String outputString = "";
        char[] caesarChars = new char[decryptWord.length()];
        for(int i = 0; i < decryptWord.length(); i++){
            caesarChars[i] = (char)(caesarArray[i]);
            outputString += caesarChars[i];
        }
        String upperOutput = outputString.toUpperCase();
        output.setText("Message: " + upperOutput);
    }

//key word; shift by position of each letter in alphabet;
    public void encryptVigenere() {
        System.out.println("vigenere");
        //convert key to string
        String keyWord = strgkey;

        //create array that contains the message:
        char[] vigenereWord = encryptWord.toCharArray();

        //create an array that contains the key word
        char[] keyArray = keyWord.toCharArray();

        //create array that contains the key word
        char[] keyedMsg = new char[vigenereWord.length];

        //array that will store the finished encryption
        char[] vigenereArray = new char[encryptWord.length()];

        /*
         *I used code from javahungry.com
         *URL: https://javahungry.blogspot.com/2019/12/vigenere-cipher-in-java.html
         *I used this code to create a multivariable loop.
         * This loop assigns the key word chars to the original message
         */
        for(int i = 0, j = 0; i < vigenereWord.length; i++, j++){
            if(j == keyArray.length){
                j = 0;
            }
            keyedMsg[i] = keyArray[j];
        }

        //This loop shifts the message based on the letter it corresponds with in the key word.
        for(int i = 0; i < keyedMsg.length; i++){
            if(encryptWord.charAt(i) + (int)(keyedMsg[i]) - 97 > 122){
                vigenereArray[i] = (char)(encryptWord.charAt(i) + (int)(keyedMsg[i]) - 97 - 26); //returns back to a
            } else if((int)(encryptWord.charAt(i)) == 32){
                vigenereArray[i] = (char)(32);
            } else {
                vigenereArray[i] = (char)(encryptWord.charAt(i) + (int)(keyedMsg[i]) - 97);
            }
        }

        //this section transfers each char from the array and puts it into a string to be printed in the app
        String outputString = "";
        for(int i = 0; i < encryptWord.length(); i++){
            outputString += vigenereArray[i];
        }
        String upperOutput = outputString.toUpperCase();
        output.setText("Message: " + upperOutput);

    }



    public void decryptVigenere(){
        System.out.println("vigenere decrpt");
        //convert key to string
        String keyWord = strgkey;

        //create array that contains the message:
        char[] vigenereWord = decryptWord.toCharArray();

        //create an array that contains the key word
        char[] keyArray = keyWord.toCharArray();

        //create array that contains the key word
        char[] keyedMsg = new char[vigenereWord.length];

        //array that will store the finished encryption
        char[] vigenereArray = new char[decryptWord.length()];


         //This loop assigns the key word chars to the original message
        for(int i = 0, j = 0; i < vigenereWord.length; i++, j++){
            if(j == keyArray.length){
                j = 0;
            }
            keyedMsg[i] = keyArray[j];
        }

        //This loop shifts the message based on the letter it corresponds with in the key word.
        for(int i = 0; i < keyedMsg.length; i++){
            if(decryptWord.charAt(i) - ((int)(keyedMsg[i]) - 97) < 97){
                vigenereArray[i] = (char)(decryptWord.charAt(i) - ((int)(keyedMsg[i]) - 97) + 26); //returns back to a
            } else if((int)(decryptWord.charAt(i)) == 32){
                vigenereArray[i] = (char)(32);
            } else {
                vigenereArray[i] = (char)(decryptWord.charAt(i) - ((int)(keyedMsg[i]) - 97));
            }
        }

        //this section transfers each char from the array and puts it into a string to be printed in the app
        String outputString = "";
        for(int i = 0; i < decryptWord.length(); i++){
            outputString += vigenereArray[i];
        }
        String upperOutput = outputString.toUpperCase();
        output.setText("Message: " + upperOutput);
    }


    public void encryptScytale(){
        System.out.println("scaytale");

        String noSpaceW = encryptWord.replaceAll(" ", "");
        /*
         * I used code from vertex-academy.com
         * URL: https://vertex-academy.com/tutorials/en/rounding-numbers-java/
         * I used this code to find the width of the multidimensional array that will store the message.
         */
        double decimalW = (double)(noSpaceW.length() / (double)(key));
        System.out.println(decimalW);
        int width = (int)Math.ceil(decimalW);
        System.out.println(width);
        int i = 0;
        char[][] scaytaleArray = new char[key][width]; //new array with a height of the key

        for(int y = 0; y < key; y++){//goes through height of array
            for(int x = 0; x < width; x++){//goes through width of array
                if(i < noSpaceW.length()) {
                    scaytaleArray[y][x] = noSpaceW.charAt(i);
                    i++;
                } else {
                    scaytaleArray[y][x] = '@';
                }
            }
        }

        String outputString = "";
        for(int x = 0; x < width; x++){//through each column
            for(int y = 0; y < key; y++){//through each row
                outputString += scaytaleArray[y][x];
            }
            String upperOutput = outputString.toUpperCase();
            //output.setText(outputString);
            output.setText("message: " + upperOutput);
        }

    }

    public void decryptScytale() {
        System.out.println("scaytale");

        /*
         * I used code from vertex-academy.com
         * URL: https://vertex-academy.com/tutorials/en/rounding-numbers-java/
         * I used this code to find the width of the multidimensional array that will store the message.
         */
        double decimalW = (double)(decryptWord.length() / (double)(key));
        System.out.println(decimalW);
        int width = (int)Math.ceil(decimalW);
        System.out.println(width);
        int i = 0;
        char[][] scaytaleArray = new char[key][width]; //new array with a height of the key

        for(int x = 0; x < width; x++){//goes through width of array
            for(int y = 0; y < key; y++){//goes through height of array
                if(i < decryptWord.length()) {
                    scaytaleArray[y][x] = decryptWord.charAt(i);
                    i++;
                } else {
                    scaytaleArray[y][x] = '@';
                }
            }
        }

        String outputString = "";
        for(int y = 0; y < key; y++){//through each row
            for(int x = 0; x < width; x++){//through each column
                outputString += scaytaleArray[y][x];
            }
            String upperOutput = outputString.toUpperCase();
            //output.setText(outputString);
            output.setText("message: " + upperOutput);
        }
    }
}
